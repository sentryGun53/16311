#pragma config(Sensor, S1,     ultrasonicSensor, sensorSONAR)
#pragma config(Sensor, S4,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// local_4.c: (hopefully) more robust turn counting
// Placeholder function that figures out where robot is after taking readings

#include "motion_functions.h"

#define LIGHT_SENSOR_BLACK 37 // 37 for black
#define LIGHT_SENSOR_WHITE 59 // 60 for white

#define PIVOT_SPEED 20
#define DEAD_ZONE_OFFSET 0.01
#define MAX_SPEED 25
#define MIN_SPEED 20

#define L 4.154 // inches (4.1 Adriel 2-13-15) (4.201 Adriel 2-10-15)
#define R 1.077 // inches (1.076285 Adriel 2-13-15) (1.0776 Adriel 2-10-15)
#define ARM_LENGTH 7
#define ARM_OFFSET 3


float robotX = 0.0, robotY = 0.0, robotTH = 0.0;
float old_TH = 0;
int velocityUpdateInterval = 5; // ms
float degrees_to_velocity = ((PI/180.0) / (velocityUpdateInterval/1000.0) * R); // units of inch/s
int thetaBPrev = 0, thetaCPrev = 0;
int turnsMade = 0;
float lastCornerX = 0, lastCornerY = 0;

bool takeReadings = true;
float readings[5][15] = {
	{0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0},
	{0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0},
	{0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0},
	{0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0},
	{0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0}
};

float calculateDistance(float x, float y) {
    return sqrt(pow(x,2) + pow(y,2));
}

task dead_reckoning()
{
	while(1)
	{
		//
		//Fill in code for numerical integration / position estimation here
		//

		int thetaBNow = nMotorEncoder[motorB];
		int thetaCNow = nMotorEncoder[motorC];

		int deltaThetaB = thetaBNow - thetaBPrev;
		int deltaThetaC = thetaCNow - thetaCPrev;

	 	// Be careful here! Here we are assuming B is the left motor
		// Swap deltaThetaB and deltaThetaC if motors are the other way round
		float vLeft = deltaThetaB * degrees_to_velocity;
		float vRight = deltaThetaC * degrees_to_velocity;
		float v = (vLeft + vRight)/2; // cm/s
		float omega = (vRight - vLeft)/L; // radians/s

		// Runge-Kutta approximation
		float t = velocityUpdateInterval/1000.0;
		float k00 = v * cos(robotTH);
		float k01 = v * sin(robotTH);

		float k10 = v * cos(robotTH + t/2 * omega);
		float k11 = v * sin(robotTH + t/2 * omega);

		float k30 = v * cos(robotTH + t * omega);
		float k31 = v * sin(robotTH + t * omega);

		robotX += t/6 * (k00 + 4*k10 + k30);
		robotY += t/6 * (k01 + 4*k11 + k31);
		robotTH += t * omega;
		// Draw position on screen
		// Screen is 99 x 63
		// Rectangle of travel is 18" x 12"
		// 63 pixels for 18"
		// 3 pixels per inch
		nxtSetPixel(50 + (int)(1 * robotX), 32 + (int)(1 * robotY));

		thetaBPrev = thetaBNow;
		thetaCPrev = thetaCNow;

		if (takeReadings) {
			// Get ultrasonic reading
			int d = SensorRaw[ultrasonicSensor];
			//nxtDisplayTextLine(0, "d: %d", d);
			float dInches = d/2.54;
			float dFromCentre = dInches + ARM_LENGTH;

			float dX = robotX + ARM_OFFSET * cos(robotTH + PI) + dFromCentre * cos(robotTH + PI/2);
			float dY = robotY + ARM_OFFSET * sin(robotTH + PI) + dFromCentre * sin(robotTH + PI/2);
			nxtSetPixel(50 + (int)(1 * dX), 32 + (int)(1 * dY));

			// Calculate distance from last corner
			float distanceAlongCurrentStraightEdge = calculateDistance(robotX-lastCornerX, robotY-lastCornerY);
			// If rounded (down) distance is a multiple of 5, add it to readings
			int step = 2;
			int units = (int) distanceAlongCurrentStraightEdge;
			nxtDisplayTextLine(1, "distance: %d", units);
			if (units % step == 0) {
				readings[turnsMade][units/step] = d;
			}
		}

		wait1Msec(velocityUpdateInterval);
	}
}


/*
// Old turnCounter()
task turnCounter() {
	while (true) {
		float delta_TH = abs(robotTH - old_TH)*57.29;
		if (45 < delta_TH) {
			turnsMade++;
			lastCornerX = robotX;
			lastCornerY = robotY;
			// Make beep!
			playTone(1000, 100); // Play tone at 1000Hz for 1000ms
		}
		nxtDisplayTextLine(0, "turns: %d", turnsMade);
		old_TH = robotTH;
		wait10Msec(150); // Wait 1.5s // This causes problems.
	}
}
*/



void followLine() {
  int sensor_reading = SensorValue[lightSensor];

	if (sensor_reading < LIGHT_SENSOR_BLACK) {
		pivot_left(PIVOT_SPEED);
	}
	else if (sensor_reading > LIGHT_SENSOR_WHITE) {
		pivot_right(PIVOT_SPEED);
	} else { // Proportional control
		// normalize sensor reading to a value between 0.0 and 1.0, where 0.0 is black and 1.0 is white
		float normalized_reading = (float)(sensor_reading - LIGHT_SENSOR_BLACK) / (float)(LIGHT_SENSOR_WHITE - LIGHT_SENSOR_BLACK);
		if (normalized_reading < 0.5 - DEAD_ZONE_OFFSET) {
			// turn right proportionally
			int off_center_amount = 0.5 - normalized_reading; // 0.0 to 0.5
			int adjust_speed = off_center_amount * 2 * (MAX_SPEED - MIN_SPEED);
			motor[motorB] = MAX_SPEED;
			motor[motorC] = (MAX_SPEED - adjust_speed);
		} else if (normalized_reading > 0.5 + DEAD_ZONE_OFFSET) {
			// turn left proportionally
			int off_center_amount = normalized_reading - 0.5; // 0.0 to 0.5
			int adjust_speed = off_center_amount * 2 * (MAX_SPEED - MIN_SPEED);
			motor[motorB] = (MAX_SPEED - adjust_speed);
			motor[motorC] = MAX_SPEED;
		}
		else { // dead zone, go straight ahead
			motor[motorB] = MAX_SPEED;
			motor[motorC] = MAX_SPEED;
		}
	}
}



void goToDestination (int currentEdge, string letter) {
	// Figure out destination edge
	int destinationEdge = -1; // -1 is not a valid edge
	if (letter == "A" || letter == "B") destinationEdge = 0;
	else if (letter == "C" || letter == "D" || letter == "E") destinationEdge = 1;
	else if (letter == "F" || letter == "G") destinationEdge = 2;
	else if (letter == "H" || letter == "I" || letter == "J") destinationEdge = 3;

	float distanceOnEdge = 0;
	if (letter == "A" || letter == "C" || letter == "F" || letter == "H") distanceOnEdge = 2; // Closer to start because we tend to overshoot
	else if (letter == "B" || letter == "D" || letter == "G" || letter == "I") distanceOnEdge = 8;
	else if (letter == "E" || letter == "J") distanceOnEdge = 14;

	int edgesAway = (destinationEdge - currentEdge + 4) % 4;
	if (edgesAway == 0) edgesAway += 4;

	// Make edgesAway turns
	turnsMade = 0;
	while (turnsMade < edgesAway) followLine();

	// Travel until distance > distanceOnEdge
	float distanceAlongCurrentStraightEdge = calculateDistance(robotX-lastCornerX, robotY-lastCornerY);
	while (distanceAlongCurrentStraightEdge < distanceOnEdge) {
		followLine();
		distanceAlongCurrentStraightEdge = calculateDistance(robotX-lastCornerX, robotY-lastCornerY);
		nxtDisplayTextLine(1, "distance: %d", distanceAlongCurrentStraightEdge);
	}

	// Come to a stop
	motor[motorB] = 0;
	motor[motorC] = 0;
}




void saveReadingsToFile() {
	/*
	// Print first five readings per reading to screen
	for (int i=0; i < 5; i++) {
		nxtDisplayTextLine(i+1, "%d: %d,%d,%d,%d,%d", i, readings[i][0], readings[i][1], readings[i][2], readings[i][3], readings[i][4]);
	}
	*/

	// Save readings to file
	TFileHandle output;
	TFileIOResult result;
	int sizeOfFloat = 8;
	short fileSize = 5*15*sizeOfFloat;
	string fileName = "readings.txt";
	Delete(fileName, result);
	OpenWrite(output, result, fileName, fileSize);
	for (int i=0; i < 5; i++) {
		for (int j=0; j < 15; j++) {
			string str = "";
			StringFormat(str, "%.1f", readings[i][j]);
			WriteString(output, result, str);
		}
		WriteString(output, result, "");
	}
	Close(output, result);
}



// New turn counter
task turnCounter() {
	while (true) {
		float delta_TH = abs(robotTH - old_TH)*57.29; // In degrees
		if (80 < delta_TH) {
			turnsMade++;
			lastCornerX = robotX;
			lastCornerY = robotY;
			// Make beep!
			playTone(1000, 100); // Play tone at 1000Hz for 1000ms

			wait1Msec(1000); // Wait 1s to get back on straight path so old_TH is accurate
			old_TH = robotTH;
		}
		nxtDisplayTextLine(0, "turns: %d", turnsMade);

		wait1Msec(velocityUpdateInterval); // Wait a while so we don't do this too often
	}
}




task main()
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

	time1[T1] = 0;
	startTask(dead_reckoning);
	startTask(turnCounter);

	nNxtButtonTask  = 0;
	nNxtExitClicks = 2;

	/*
	// Comment out to test goToDestination()
	while (turnsMade < 5) { //(nNxtButtonPressed != kExitButton && (time100[T1] < 50 || (abs(robotX) > 2 || abs(robotY) > 2) ) ) {
		followLine();
	}
	*/

	takeReadings = false;
	// Maybe it should go for a bit more so that it isn't along an edge?
	motor[motorB] = 0;
	motor[motorC] = 0;

	// saveReadingsToFile();

		// Based on values in readings, figure out where we are using probabilistic model
		// Edge 0 is top edge, 1 is right, 2 is bottom and 3 is left
		// int currentEdge = figureOutWhereWeAre();
		int currentEdge = 0;
		string destinationLetter = "A";
		goToDestination(currentEdge, destinationLetter);

		while (nNxtButtonPressed != kExitButton) {}

}
